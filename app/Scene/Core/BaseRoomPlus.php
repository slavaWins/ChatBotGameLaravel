<?php

namespace App\Scene\Core;

use App\Characters\CarCharacter;
use App\Helpers\PaginationHelper;
use App\Library\Structure\BotResponseStructure;
use App\Models\Bot\Character;
use App\Scene\HomeRoom;

class BaseRoomPlus extends BaseRoom
{
    /**
     * Используется для Селектора, что бы понимать что он выбрал и не обновлять страницу
     * @var Character|null
     */
    public ?Character $_selectorData;


    function SetStep($step): BotResponseStructure
    {
        $this->_selectorData = null;
        return parent::SetStep($step); // TODO: Change the autogenerated stub
    }

    /**
     * Вывести пагинированый список моих чарактеров по их классу. С кнопкой. И переходм на другой шаг. С кнопкой выхода в хоум.
     * Дополнительные кнопки и контент лучше добавлять перед функцией, иначе контент будет перенесен на другой шаг
     * @param $characterClass
     * @param $title
     * @param $moveToStep
     * @param $exitBtn
     * @return BotResponseStructure|mixed
     */
    public function RenderMyCharactersList($characterClass, $title = "Мои предметы", $moveToStep = 1, $exitBtn = "Назад")
    {
        /** @var CarCharacter[] $items */
        $items = $this->user->GetAllCharacters($characterClass);

        $this->response->message .= $title . " (" . (count($items)) . " шт): \n";

        $isRedirect = $this->PaginateCollection(collect($items), 4, function ($item) use ($moveToStep) {
            $this->response->message .= "\n\n" . $item->Render(true, false, false);

            if ($moveToStep) {
                if ($this->AddButton($item->name ?? $item->baseName)) {
                    $this->scene->SetData('id', $item->id);
                    $this->scene->save();
                    return $this->SetStep($moveToStep);
                }
            }

        });

        if ($isRedirect) return $isRedirect;

        if ($exitBtn) {
            if ($this->AddButton($exitBtn)) {
                return $this->SetRoom(HomeRoom::class);
            }
        }

        return $this->response;
    }


    /**
     * Быстрый селектор данных. Возвращает выбранного из списка чарактера. Сам норм пагинирует всё, и вообще збс
     * @param $charactersListCollection
     * @return Character|null
     */
    public function PaginateSelector($charactersListCollection, $isOnlyName = false)
    {

        if (!$charactersListCollection) {
            $this->response->message .= "Ничего не найдено";
            return;
        };
        if (!$charactersListCollection->count()) return null;

        $this->PaginateCollection($charactersListCollection, 6, function (Character $V) use ($isOnlyName) {
            $this->response->message .= "\n";
            $stats = "";
            if ($isOnlyName) {
                $stats = $V->GetName();
            } else {
                $stats = "\n" . $V->Render(true);
                //  $stats = str_replace("\n", " ", $stats);
            }

            $this->response->message .= $stats;

            if ($this->AddButton($V->name)) {
                $this->_selectorData = $V;
            }
        });

        $response = $this->_selectorData ?? null;

        if (is_object($response)) {
            if (substr_count(get_class($response), "Character")) {
                return $response;
            }
        }

        return null;
    }

    public function PaginateCollection($listCollection, $inPage, $callback)
    {
        if (!isset($this->scene->sceneData['page'])) {
            $this->scene->SetData('page', 1);
            $this->scene->save();
        }

        $pageCurent = $this->scene->sceneData['page'];
        $pageCountMax = ceil($listCollection->count() / $inPage);

        if ($pageCurent > $pageCountMax) {
            $pageCurent = $pageCountMax;
            $this->scene->SetData('page', $pageCurent);
        }

        $paginated = PaginationHelper::paginate($listCollection, $inPage, $pageCurent);

        foreach ($paginated as $item) {
            $response = $callback($item);

            if (is_object($response)) {
                if (substr_count(get_class($response), "BotResponseStructure")) {
                    // $this->response->Reset();
                    $this->request->message = "";
                    return $response;
                } else {
                    return $response;
                }
            }
        }

        if ($pageCountMax > 1) {
            if ($pageCurent > 1) {
                if ($this->AddButton("<")) {
                    $this->scene->SetData('page', $pageCurent - 1);
                    $this->scene->save();
                    $this->response->Reset();
                    $this->request->message = "";
                    return $this->Handle();
                }
            }
        }


        if ($pageCountMax > 1) {
            if ($pageCurent < $pageCountMax) {
                if ($this->AddButton(">")) {
                    $pageCurent += 1;
                    $this->scene->SetData('page', $pageCurent);
                    $this->scene->save();
                    $this->response->Reset();
                    $this->request->message = "";
                    return $this->Handle();
                }
            }
            $this->response->message .= "\n\n Страница " . ($pageCurent) . " / " . ($pageCountMax) . "";
        }

        return null;
    }


}
